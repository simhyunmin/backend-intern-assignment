## 채점 기준

### 1. 과제 분석 과정

과제를 처음 받았을 때 가장 고민되었던 건 3시간이라는 짧은 시간 안에 기능을 완성하면서도 과제에서 요구하는 '확장성'을 어떻게 증명할지였습니다. <br><br>
그래서 저는 바로 코드를 짜는 대신 AI를 활용해 과제를 먼저 분석해보기로 했습니다. <br>
우선 ChatGPT의 맞춤형 버전인 prompt engineer를 활용해 "전략적으로 어떤걸 준비하면 좋을 지"를 물어봐서 분석을 위한 프롬프트를 만들었고 이 질문들을 과제 설명서와 함께 Gemini에게 입력해 제가 미처 생각하지 못했던 제약 사항이나 아키텍처 설계 시 주의할 점들을 먼저 파악했습니다.<br><br>
이 분석 과정을 통해 저는 '시간 내 구현이 가능한 범위'와 '나중에 확장이 가능한 구조' 사이의 기준을 잡을 수 있었고 이를 바탕으로 저만의 '프로젝트 설계 지침'을 정리했습니다. <br><br>
여기에 "너무 복잡한 아키텍처(헥사고날 등) 욕심은 버리고 기본에 충실하되 나중에 기능을 붙일 수 있게 인터페이스는 열어두자"는 구체적인 전략을 추가했습니다. 그리고 실제 개발을 시작할 때 이 지침 내용을 프로젝트의 Gemini CLI 채팅창에 미리 입력해 주었습니다.<br>
덕분에 매번 "이런 구조로 짜줘"라고 설명하지 않아도 AI가 제 의도를 이해하는 코드를 제안해 주어 개발에만 집중할 수 있었습니다.

### 2. 과제 진행에 AI를 활용한 방식과 그 과정에서의 어려움

Gemini CLI를 프로젝트 위에서 실행하여 실시간으로 코드를 짜고 리팩토링하는 데 적극적으로 활용했습니다. <br>
가장 힘들었던 점은 AI의 '할루시네이션'과 '리소스 제한'이었습니다. <br><br>
가끔 명확한 에러 원인이 있는데도 불구하고 AI가 엉뚱한 해결책을 제시하며 빙빙 돌아서 답을 줄 때가 있었습니다. 이럴 때마다 아까운 시간이 꽤 많이 허비되어 어려움을 겪었습니다. <br><br>
또한 학생 인증을 받은 프로 계정임에도 불구하고 과제 진행 중 토큰 사용량이 많아지자 모델 성능이 다운그레이드되는 현상이 발생했습니다. 하필 중요한 로직을 구현하던 중에 답변의 질이 떨어져서 이 문제를 해결하느라 중간에 꽤나 애를 먹었습니다.

### 3. 구현하기 가장 어려웠던 1개 이상의 기능

시간 부족으로 구현의 완성도가 다소 떨어진 기능도 꽤 있었지만 그중에서 가장 깊이 고민했던 기능은 고객사 요청 사항 중 '스레드 관리' 부분이었습니다. <br><br>
처음에는 Spring AI의 인메모리(In-memory) DB 기능을 활용하면 대화 컨텍스트 유지가 쉽다는 사실을 알고 있어 그 방식을 쓰려고 했습니다. <br>
하지만 '마지막 질문 후 30분이 지난 시점에 질문할 경우 새 스레드 생성'이라는 까다로운 조건을 맞닥뜨렸을 때 단순히 메모리에만 의존해서는 시간 경과에 따른 상태 분기를 처리하기가 애매하다는 생각이 들었습니다. <br><br>
또한 현실적인 운영 문제도 고민이 되었습니다. 만약 사용자가 비속어를 사용해서 관리자가 해당 내용을 급하게 삭제해야 한다면 인메모리에 이미 쌓여버린 대화 객체 리스트를 찾아내 수정하고 다시 컨텍스트에 반영하는 과정이 기술적으로 꽤나 골치 아플 것 같았습니다. <br><br>
그래서 '왜 굳이 RDBMS(PostgreSQL)를 써야 할까?'를 고민하던 중 "여기서 스레드를 DB 테이블로 관리해두면, 데이터 삭제나 관리가 쉬워지는 건 물론이고 나중에 pgvector 같은 기능을 통해 기존 데이터를 바로 벡터 DB로 전환할 수 있겠다"는 생각이 들었습니다. <br>
그렇게 되면 추후 고객사가 자사 문서를 넣어 RAG(검색 증강 생성)를 구축하고 싶을 때도 필요한 문맥만 검색해서 주입하는 방식을 통해 훨씬 수월하게 대응할 수 있을 것 같았습니다. 그래서 과감히 인메모리 방식은 버리고 DB를 통해 스레드를 관리하는 방식으로 구현하게 되었습니다.<br><br>
이와 더불어 '아키텍처의 수위 조절' 또한 기술적 구현 못지않게 고민되었던 포인트였습니다.<br><br>
과제 요구사항에 적힌 '확장성'이라는 단어를 보자마자 헥사고날 아키텍처나 멀티 모듈 같은 구조를 도입하자는 생각이 들었습니다. <br>
하지만 3시간이라는 제한된 시간 안에 그런 복잡한 구조를 세팅하다가는 정작 핵심 비즈니스 로직을 완성하지 못할 위험이 커 보였습니다.<br><br>
결국 "어디까지가 MVP이고 어디부터가 오버 엔지니어링인가?"를 끊임없이 고민했습니다. 결론적으로 저는 Layered Architecture가 단순히 구현하기 쉽기 때문이 아니라 "현재 단계에서 확장성을 확보할 수 있는 실리적인 구조"라고 확신하여 선택했습니다.<br><br>
Layered 구조는 데이터 흐름이 직관적이라 개발 속도가 빠르다는 확실한 장점이 있습니다. 여기에 의존성 역전 원칙(DIP)만 확실하게 적용한다면 굳이 복잡한 헥사고날 구조를 쓰지 않더라도 외부 시스템을 언제든 갈아 끼울 수 있는 유연함은 충분히 가져갈 수 있다고 판단했기 때문입니다.<br>
